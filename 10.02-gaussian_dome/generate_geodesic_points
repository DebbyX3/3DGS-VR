import open3d as o3d
import numpy as np
import struct
from plyfile import PlyData, PlyElement
import pycolmap

def icosphere(subdivisions=2, radius=1.0, center=np.array([0.0, 0.0, 0.0]), return_centroids=False):
    t = (1.0 + np.sqrt(5.0)) / 2.0
    vertices = np.array([[-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
                         [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
                         [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]])
    vertices /= np.linalg.norm(vertices[0])
    vertices *= radius
    
    faces = np.array([[0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
                      [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
                      [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
                      [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]])
    
    def midpoint(v1, v2):
        mid = (v1 + v2) / 2.0
        return mid / np.linalg.norm(mid) * radius
    
    for _ in range(subdivisions):
        new_faces = []
        midpoint_cache = {}
        
        def get_midpoint(i1, i2):
            if (i1, i2) not in midpoint_cache:
                if (i2, i1) in midpoint_cache:
                    return midpoint_cache[(i2, i1)]
                midpoint_cache[(i1, i2)] = len(vertices)
                vertices.append(midpoint(vertices[i1], vertices[i2]))
            return midpoint_cache[(i1, i2)]
        
        vertices = list(vertices)
        for f in faces:
            a, b, c = f
            ab = get_midpoint(a, b)
            bc = get_midpoint(b, c)
            ca = get_midpoint(c, a)
            new_faces.extend([[a, ab, ca], [b, bc, ab], [c, ca, bc], [ab, bc, ca]])
        
        faces = np.array(new_faces)
        vertices = np.array(vertices)
    
    if return_centroids:
        centroids = np.mean(vertices[faces], axis=1)
        return centroids + center, faces
    
    return vertices + center, faces

def save_as_ply(points, filename="gaussians.ply", color=[255, 255, 255]):
    normals = -points / np.linalg.norm(points, axis=1, keepdims=True)  # Verso il centro
    vertex_data = np.array([
        (p[0], p[1], p[2], c[0], c[1], c[2], n[0], n[1], n[2])
        for p, c, n in zip(points, [color] * len(points), normals)],
        dtype=[('x', 'f4'), ('y', 'f4'), ('z', 'f4'),
               ('red', 'u1'), ('green', 'u1'), ('blue', 'u1'),
               ('nx', 'f4'), ('ny', 'f4'), ('nz', 'f4')])
    ply_element = PlyElement.describe(vertex_data, 'vertex')
    PlyData([ply_element]).write(filename)

def find_most_distant_point(point_cloud, initial_point):
    # Convert point cloud to numpy array
    points = np.asarray(point_cloud.points)
    
    # Calculate the Euclidean distance from the initial point to all points in the point cloud
    distances = np.linalg.norm(points - initial_point, axis=1)
    
    # Find the index of the maximum distance
    max_distance_index = np.argmax(distances)
    
    # Get the most distant point
    most_distant_point = points[max_distance_index]
    
    # Get the maximum distance
    max_distance = distances[max_distance_index]
    
    return most_distant_point, max_distance

def calculate_circumradius(vertices, faces):
    circumradii = []
    for face in faces:
        a, b, c = vertices[face]
        # Lengths of sides of the triangle
        ab = np.linalg.norm(a - b)
        bc = np.linalg.norm(b - c)
        ca = np.linalg.norm(c - a)
        # Semi-perimeter
        s = (ab + bc + ca) / 2
        # Area of the triangle using Heron's formula
        area = np.sqrt(s * (s - ab) * (s - bc) * (s - ca))
        # Circumradius formula
        circumradius = (ab * bc * ca) / (4 * area)
        circumradii.append(circumradius)
    return max(circumradii)

def create_circle(center, normal, radius, resolution=30):
    """
    Create a circle in 3D space using Open3D.
    
    Parameters:
    - center: The center of the circle.
    - normal: The normal vector of the circle plane.
    - radius: The radius of the circle.
    - resolution: The number of points to generate the circle.
    
    Returns:
    - circle: An Open3D LineSet representing the circle.
    """
    theta = np.linspace(0, 2 * np.pi, resolution)
    circle_points = np.array([radius * np.cos(theta), radius * np.sin(theta), np.zeros_like(theta)]).T
    
    # Create a rotation matrix to align the circle with the normal vector
    z_axis = np.array([0, 0, 1])
    normal = normal / np.linalg.norm(normal)
    v = np.cross(z_axis, normal)
    c = np.dot(z_axis, normal)
    k = np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])
    rotation_matrix = np.eye(3) + k + k @ k * (1 / (1 + c))
    
    # Rotate and translate the circle points
    circle_points = circle_points @ rotation_matrix.T + center
    
    # Create the LineSet for the circle
    lines = [[i, (i + 1) % resolution] for i in range(resolution)]
    circle = o3d.geometry.LineSet()
    circle.points = o3d.utility.Vector3dVector(circle_points)
    circle.lines = o3d.utility.Vector2iVector(lines)
    return circle

sparse_folder = '../../gaussian-splatting-new/gaussian-splatting/data/brg_rm_small_park_test/sparse/0/'

reconstruction = pycolmap.Reconstruction(sparse_folder)
print(reconstruction.summary())

# LINESET to draw camera directions in 3d as 'vectors'
lineset = o3d.geometry.LineSet()
all_points = []
all_lines = []

# loop on all images
camera_data = {}

for i in range(1, reconstruction.num_images() + 1):
    image = reconstruction.image(i)

    camera_coords = image.projection_center()
    direction_vector = image.viewing_direction()

    # cerca il punto finale per fare sta linea
    # punto di inizio Ã¨ la camera stessa
    # punto finale = punto inizio + direzione * lunghezza vettore
    final_point = camera_coords + direction_vector * 1.5

    # ora traccio linea
    all_points.append(camera_coords)
    all_points.append(final_point)

    # Aggiungi la linea tra gli ultimi due punti aggiunti
    idx = len(all_points)
    all_lines.append([idx - 2, idx - 1])  # Indici degli ultimi due punti

    # Store camera data
    camera_data[i] = {
        "center": camera_coords,
        "direction": direction_vector
    }

'''
# Accessing the values outside the loop
for camera_id, data in camera_data.items(): # camera_id = key, data = value
    print(f"Camera {camera_id} center: {data['center']}")
    print(f"Camera {camera_id} direction: {data['direction']}")
'''


# -------- Find center of all cameras (center of point cloud)

# Create new point cloud, add camera centers
cameras_point_cloud = o3d.geometry.PointCloud()
# extract from dict
cameras_coords = [data['center'] for data in camera_data.values()]
cameras_point_cloud.points = o3d.utility.Vector3dVector(cameras_coords)
cameras_mass_center = cameras_point_cloud.get_center()

most_distant_point, max_distance = find_most_distant_point(cameras_point_cloud, cameras_mass_center)
print("Most distant point:", most_distant_point)
print("Distance:", max_distance)



# --------- create icosphere based on max_distance
# radius = max_distance * 2
ico_points_pos, ico_faces = icosphere(subdivisions = 5, 
                            radius = max_distance * 2, 
                            center = cameras_mass_center, 
                            return_centroids = False) #keep false!!!!!!!!!!!

print("num of icosphere points generated: ", ico_points_pos.size/3)
print("radius of icosphere: ", max_distance * 2)

icosphere_pc = o3d.geometry.PointCloud()
icosphere_pc.points = o3d.utility.Vector3dVector(ico_points_pos)



# --------- find optimal radius of circles of point on the icosphere to cover all other circles
optimal_radius = calculate_circumradius(ico_points_pos, ico_faces)
print("Optimal radius for circles:", optimal_radius)


# --------- Create circles on the icosphere points
circles = []

for point in ico_points_pos:
    circle = create_circle(center=point, normal=point - cameras_mass_center, radius=optimal_radius)
    circles.append(circle)


# ------- SHOW CAMERAS IN 3D (RED) + FORWARD VECTOR (GREEN)
# Paint camera coords red
cameras_point_cloud.paint_uniform_color([1, 0, 0])

# Create lineset
lineset.points = o3d.utility.Vector3dVector(all_points)
lineset.lines = o3d.utility.Vector2iVector(all_lines)

# Apply color to lineset
GREEN = [0.0, 1.0, 0.0]
lines_color = [GREEN] * len(lineset.lines)
lineset.colors = o3d.utility.Vector3dVector(lines_color)

o3d.visualization.draw_geometries([lineset, cameras_point_cloud, icosphere_pc] + circles)

save_as_ply(ico_points_pos, "points3D.ply")