import numpy as np
import os
import matplotlib.pyplot as plt
from scipy.spatial.transform import Rotation as R

def parse_cameras(camera_file_path):
    # ************** READ COLMAP CAMERA.TXT FILE    

    # ***  WARNING: THIS SCRIPT ASSUMES THAT ALL CAMERAS HAVE THE SAME INTRINSICS ***
    # ***  SO IN THE CAMERA.TXT FILE WE WILL ONLY READ THE FIRST CAMERA INTRINSICS ***
    # *** (ALSO BEACUSE THERE IS ONLY ONE CAMERA IN THE CAMERA.TXT FILE IF THEY SHARE THE SAME INTRINSICS) ***

    # Camera list with one line of data per camera:
    #   CAMERA_ID, MODEL, WIDTH, HEIGHT, PARAMS[]
    #
    # In case of Pinhole camera model (example):
    # 1 PINHOLE 3072 2304 2560.56 2560.56 1536 1152
    # 
    # In case of Simple Pinhole camera model (example):
    # 2 SIMPLE_PINHOLE 3072 2304 2559.81 1536 1152
    #
    # In case of Simple Radial camera model (example):
    # 3 SIMPLE_RADIAL 3072 2304 2559.69 1536 1152 -0.0218531

    cameras_info = {}

    # Load the camera intrinsics 
    with open(camera_file_path, 'r') as f:
        for line in f:    
            # Ignore comments
            if not line.startswith("#"):
                single_camera_info = line.split() # split every field in line

                # Camera info contains:
                # CAMERA_ID  MODEL   WIDTH   HEIGHT  PARAMS[]
                # 0          1       2       3       4   5   6   7   8
                # Where PARAMS[] are:
                # SIMPLE_PINHOLE: fx (fx = fy), cx, cy      1 focal length and principal point
                # PINHOLE: fx, fy, cx, cy                   2 focal lenghts and principal point
                # SIMPLE_RADIAL: fx (fx = fy), cx, cy, k1   1 focal length, principal point and radial distortion
                # RADIAL: fx (fx = fy), cx, cy, k1, k2      1 focal lengths, principal point and 2 radial distortions

                camera_id = int(single_camera_info[0])

                camera_width = int(single_camera_info[2])
                camera_height = int(single_camera_info[3])

                if single_camera_info[1] == "SIMPLE_PINHOLE":
                    fx = float(single_camera_info[4])
                    fy = float(single_camera_info[4]) #same as fx
                    cx = float(single_camera_info[5])
                    cy = float(single_camera_info[6])

                if single_camera_info[1] == "PINHOLE":
                    fx = float(single_camera_info[4])
                    fy = float(single_camera_info[5]) 
                    cx = float(single_camera_info[6])
                    cy = float(single_camera_info[7])

                if single_camera_info[1] == "SIMPLE_RADIAL":
                    fx = float(single_camera_info[4])
                    fy = float(single_camera_info[4]) #same as fx
                    cx = float(single_camera_info[5])
                    cy = float(single_camera_info[6])
                    k1 = float(single_camera_info[7])

                if single_camera_info[1] == "RADIAL":
                    fx = float(single_camera_info[4])
                    fy = float(single_camera_info[4]) #same as fx
                    cx = float(single_camera_info[5])
                    cy = float(single_camera_info[6])
                    k1 = float(single_camera_info[7])
                    k2 = float(single_camera_info[8])  

                cameras_info[camera_id] = {'type': single_camera_info[1], 'width': camera_width, 'height': camera_height, 'fx': fx, 'cx': cx, 'cy': cy}
                
                print("--- Camera: ", cameras_info[camera_id]['type'])
                print(" Width: ", camera_width)
                print(" Height: ", camera_height)
                print(" fx: ", fx)
                print(" fy: ", fy)
                print(" cx: ", cx)
                print(" cy: ", cy)  

                if 'k1' in locals():
                    print(" k1: ", k1)
                if 'k2' in locals():
                    print(" k2: ", k2)

                break    # We only need the first camera intrinsics (assume all cameras have the same intrinsics)  

    # Create the camera intrinsic matrix
    intrinsic_matrix = np.array([[fx, 0, cx],
                                [0, fy, cy],
                                [0, 0, 1]])

    return cameras_info, intrinsic_matrix

def parse_images(file_path):
    """Parsa il file images.txt per estrarre le pose delle immagini e le corrispondenze 2D-3D."""
    images = {}
    with open(file_path, 'r') as f:
        lines = f.readlines()
        i = 0
        while i < len(lines):
            if lines[i].startswith('#') or not lines[i].strip():
                i += 1
                continue
            parts = lines[i].split()
            img_id = int(parts[0])
            qw, qx, qy, qz = map(float, parts[1:5])
            tx, ty, tz = map(float, parts[5:8])
            cam_id = int(parts[8])
            name = parts[9]
            
            rotation = R.from_quat([qx, qy, qz, qw]).as_matrix()
            translation = np.array([tx, ty, tz]).reshape(3, 1)
            extrinsic = np.hstack((rotation, translation))
            extrinsic = np.vstack((extrinsic, [0, 0, 0, 1]))
            
            keypoints = []
            i += 1
            for point in lines[i].split('\n')[0].split():
                px, py, point_id = map(float, point.split())
                keypoints.append((px, py, int(point_id)))
            
            images[img_id] = {'name': name, 'camera_id': cam_id, 'extrinsic': extrinsic, 'keypoints': keypoints}
            i += 1
    print(f"Parsed {len(images)} images")
    return images

def parse_points3D(file_path):
    """Parsa il file points3D.txt per estrarre i punti 3D validi."""
    points3D = {}
    with open(file_path, 'r') as f:
        for line in f:
            if line.startswith('#') or not line.strip():
                continue
            parts = line.split()
            point_id = int(parts[0])
            x, y, z = map(float, parts[1:4])
            points3D[point_id] = np.array([x, y, z, 1.0])
    print(f"Parsed {len(points3D)} 3D points")
    return points3D

def generate_depth_map(image, camera, points3D):
    """Genera la depth map per una singola immagine."""
    width, height = camera['width'], camera['height']
    fx, cx, cy = camera['fx'], camera['cx'], camera['cy']
    intrinsic = np.array([[fx, 0, cx], [0, fx, cy], [0, 0, 1]])
    extrinsic = image['extrinsic']
    depth_map = np.zeros((height, width))
    
    for px, py, point_id in image['keypoints']:
        if point_id == -1 or point_id not in points3D:
            continue
        
        point_cam = extrinsic @ points3D[point_id]  # Trasformazione nel sistema di riferimento della camera
        if point_cam[2] <= 0:
            continue
        
        x_proj = int(round((point_cam[0] * fx / point_cam[2]) + cx))
        y_proj = int(round((point_cam[1] * fx / point_cam[2]) + cy))
        
        if 0 <= x_proj < width and 0 <= y_proj < height:
            depth_map[y_proj, x_proj] = point_cam[2]
    
    print(f"Generated depth map for image {image['name']}")
    return depth_map

def main(colmap_folder):
    cameras = parse_cameras(os.path.join(colmap_folder, 'cameras.txt'))
    images = parse_images(os.path.join(colmap_folder, 'images.txt'))
    points3D = parse_points3D(os.path.join(colmap_folder, 'points3D.txt'))
    
    depth_maps = {}
    for img_id, img_data in images.items():
        camera = cameras[img_data['camera_id']]
        depth_map = generate_depth_map(img_data, camera, points3D)
        depth_maps[img_data['name']] = depth_map
        
        plt.imshow(depth_map, cmap='viridis')
        plt.colorbar()
        plt.title(f"Depth Map: {img_data['name']}")
        plt.show()
    
    return depth_maps

# Esegui lo script
if __name__ == "__main__":
    colmap_folder = "../datasets/colmap_reconstructions/cavignal-fountain_pinhole_1camera/sparse/"  # Modifica con il percorso corretto
    depth_maps = main(colmap_folder)
    for img_name, depth_map in depth_maps.items():
        np.save(f"{img_name}_depth.npy", depth_map)  # Salva ogni depth map come file NumPy
